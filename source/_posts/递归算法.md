---
title: 递归算法
date: 2021-09-09 10:25:34
tags: 
- 递归
- 斐波那契数列
- 汉诺塔问题
categories: 学习笔记
description: 记录下学习的递归算法
---
### 爬楼梯问题
来看这道题: 
```txt
假设有n层楼梯，我们可以选择一次爬一层，也可以选择一次爬两层，求爬到顶层可用的爬楼方法
例如：
n=3时，有1+1+1、1+2、2+1三种方式可以到达，此时结果为3
n=2时，有1+1，2两种方式可以到达，此时结果为2
```

我们分析一下这道题。  
假如爬n层楼梯总共有f(n)种方法，我们第一次爬共有两种可能。
- 爬1层 &ensp;&ensp;(还需要爬n-1层，共f(n-1)种方法)
- 爬2层 &ensp;&ensp;(还需要爬n-2层，共f(n-2)种方法)

即f(n)=f(n-1)+f(n-2)
因此，要解这道题，我们只需要一步步将其拆分
```txt
f(n)=f(n-1)+f(n-2)
f(n-1)=f(n-2)+f(n-3)
f(n-2)=f(n-3)+f(n-4)
...
f(4)=f(3)+f(2)
f(3)=f(2)+f(1)
f(2)=2
f(1)=1
```

计算出每一步的结果，将其组合便能得到爬n层的方法总数  
像这样，通过重复将问题分解为同类子问题而解决问题的方法叫做递归

### 递归
    递归(recursion)在电脑科学中是指一种通过重复将问题分解为同类子问题而解决问题的方法
    ————摘自维基百科

简单来说，递归表现为函数调用函数自身  
函数逐层调用自身称为递，函数逐层返回结果称为归

### 栈溢出
来看个递归的例子:
```java
void method(){
    method();
}
```
这是最简单的递归程序，执行时，函数将不断调用自身。  
然而，当你去调用它时，会发现程序报`StackOverflowError`错误。 

`StackOverflowError`也叫栈空间溢出错误。

在计算机中，函数调用是通过栈(stack)这种数据结构实现的，每当程序执行一次函数调用，栈就会增加一层栈帧；每当函数返回，栈就会减少一层栈帧。但是栈的大小不是无限的，所以当递归调用函数的次数过多时，就会导致栈溢出。  

为了防止栈溢出，在设计递归程序时，就必须注意设定一个表达式判断来告诉程序是否该继续递归下去

### 什么问题可以用递归求解？
1. 一个问题可以分解为多个与原问题类型相同的子问题
2. 问题本身与分解后的子问题，除了数据规模不同，求解算法完全相同
3. 存在递归终止条件

&ensp;&ensp;~~这是从我学校的算法书上抄下来的原话（~~

### 求解爬楼梯问题的递归程序
#### 暴力破解法
```java
// 递归解决爬楼梯问题
int stairs(int n) {
    // 递归终止条件
	if(n==1)return 1;
	if(n==2)return 2;
	return stairs(n-1)+stairs(n-2);
}
```

这就是典型的递归程序了，在用此函数解决原问题时，第一次调用会将原问题分解为两个子问题，而每个子问题也都将面临两个选择，不断分支。直到n==1或者n==2时，解变为已知，开始返回，子问题的解不断向上层返回，最终得到原问题的解  

这种遍历所有情况的算法也叫暴力破解法。

#### 代码优化思想
我们重新来分析解题步骤
```txt
f(n)=f(n-1)+f(n-2)
f(n-1)=f(n-2)+f(n-3)
```
- n层问题分解为n-1层问题与n-2层问题  
- n-1层问题分解为n-2层问题与n-3层问题

n-2层问题被计算了两次！而当我们继续分解子问题时，发现每个子问题都被计算了若干次，这显然是很耗费计算资源的。  

为了解决这个问题，我们可以引入一个备忘录，每当计算好一层问题，就将结果存入备忘录，当再次遇到该层问题时，只需从备忘录中取值，而无需重新计算。

#### 备忘录算法
```java
//备忘录算法解决爬楼梯问题
public static int memorandumStairs(int i) {
    // 建立备忘录
    // 备忘录大小设置为i+1,使数组下标与楼层对应
	int[] memo = new int[i+1];
    // 调用递归函数
	return helperStairs(memo,i);
}
	
public static int helperStairs(int[] memo,int i) {
    // 递归终止条件
    // 当i==1或者i==2时返回已知解
	if(i==1)return 1;
	if(i==2)return 2;
    // 当备忘录中有该层的解时，直接返回备忘录中的解
	if(memo[i]!=0)return memo[i];
    // 否则，将该层解存入备忘录
	memo[i] = helperStairs(memo,i-1)+helperStairs(memo,i-2);
    // 返回该层解
	return memo[i];
}
```

### 斐波那契数列
    0，1，1，2，3，5，8，13，21...
```txt
f(n)={
    0,            (n=0)
    1,            (n=1)
    f(n-1)+f(n-2),(n≥2)
}
```
这样的一组数列称为斐波那契数列，用文字来说，就是该数列的第零项为0，第一项为1，之后的每一项都是前两数相加而得出  

我们通过求解爬楼梯问题很容易发现，爬楼梯问题的解其实是斐波那契数列的一部分  

斐波那契数列在数学，生活甚至自然界中都很常用到，从氢原子能级问题到植物的生长甚至股市等等问题都与斐波那契数列分不开，有兴趣的可以自己去了解下，这里不再细说。  

~~而与程序员最相关的，其实是它在面试中很常被问到~~

### 汉诺塔问题
```txt
有三根杆子A、B、C。A杆上有N个(N>1)穿孔圆盘，盘的尺寸由下到上依次变小。
按照如下规则将所有圆盘移到C杆：
1. 每次只能移动一个圆盘
2. 大盘不能叠在小盘上面
问：如何移？最少要移动多少次？
```

#### 解题思想
如何将A杆上的N个圆盘移动到C杆？
1. 将A杆上的N-1个圆盘移动到B杆
2. 将A杆上的第N个圆盘移动到C杆
3. 将B杆上的N-1个圆盘移动到C杆

汉诺塔问题可分解为如上三个子问题，而第1、第3个子问题，又是汉诺塔问题，可以继续分解。

当A杆或B杆上只剩一个圆盘时，可以直接移动到C杆

因此该问题可用递归求解

#### 求解代码
```java
public class Tower {

    // 静态变量，用于记录移动次数
	static int i=0;
	
	public static void main(String[] args) {
        // 调用递归函数
        // 测试盘子总数为3时的情况
		towerOfHanoi(3, 'A', 'B', 'C');
        // 打印移动次数
		System.out.println("共移动了"+i+"次"); 
	}
	
    /*
        函数功能:   将a杆上的n个盘子借助b杆移动到c杆

        @Param n    需要移动的盘子总数
        @Param a    盘子移动的起始杆子
        @Param b    盘子移动的中间杆子
        @Param c    盘子移动的目标杆子
    */
	public static void towerOfHanoi(int n,char a,char b, char c) {
		if(n==1) {
            // 当需要移动的盘子总数为1时，直接将其移动到c
			move(n,a,c);
		}else {
            // 将a上的n-1个圆盘移动到b
			 towerOfHanoi(n-1, a, c, b);
            // 将a上的第n个圆盘移动到c
			 move(n,a,c);
            // 将b上的n-1个圆盘移动到c
			 towerOfHanoi(n-1, b, a, c);
		}
	}
	
    /*
        函数功能:   将a杆上编号为n的盘子移动到c杆

        @Param n    移动的盘子编号
        @Param a    盘子移动的起始杆子
        @Param c    盘子移动的目标杆子
    */
	public static void move(int n,char a,char c) {
		System.out.println("将第"+n+"个圆盘从"+a+"移动到"+c);
        // 每移动一次，移动次数+1
		i++;
	}
}
```
